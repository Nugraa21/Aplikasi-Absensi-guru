```yaml
name: absensi_guru
description: A Flutter app for teacher attendance with selfie and GPS.

publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  camera: ^0.11.0+2
  geolocator: ^13.0.1
  permission_handler: ^11.3.1
  path_provider: ^2.1.5
  sqflite: ^2.4.0
  sqflite_common_ffi: ^2.3.2
  image_picker: ^1.1.2
  intl: ^0.19.0
  path: ^1.8.3
  csv: ^5.0.2  # For CSV export

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0

flutter:
  uses-material-design: true
```

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'screens/login_page.dart';
import 'services/db_helper.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await DBHelper.initDB();
  // Seed data if needed (call once)
  await _seedData();
  runApp(const MyApp());
}

Future<void> _seedData() async {
  final dbHelper = DBHelper();
  // Check if super_admin exists, if not insert
  final superAdminCount = Sqflite.firstIntValue(
    await dbHelper.database.query('users', where: 'username = ?', whereArgs: ['super'])
  );
  if (superAdminCount == null || superAdminCount == 0) {
    await dbHelper.insertUser({
      'username': 'super',
      'password': 'admin123', // Note: For POC only; use hashing in production
      'name': 'Super Admin',
      'role': 'super_admin',
      'type': 'pns',
      'nip': '1234567890',
      'npwp': '0000000000',
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
    });
  }

  // Admin
  final adminCount = Sqflite.firstIntValue(
    await dbHelper.database.query('users', where: 'username = ?', whereArgs: ['admin'])
  );
  if (adminCount == null || adminCount == 0) {
    await dbHelper.insertUser({
      'username': 'admin',
      'password': 'admin123',
      'name': 'Admin',
      'role': 'admin',
      'type': 'pns',
      'nip': '0987654321',
      'npwp': '1111111111',
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
    });
  }

  // Guru 1
  final guru1Count = Sqflite.firstIntValue(
    await dbHelper.database.query('users', where: 'username = ?', whereArgs: ['guru1'])
  );
  if (guru1Count == null || guru1Count == 0) {
    await dbHelper.insertUser({
      'username': 'guru1',
      'password': 'guru123',
      'name': 'Guru Satu',
      'role': 'guru',
      'type': 'pns',
      'nip': '1111111111',
      'npwp': '2222222222',
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
    });
  }

  // Guru 2 non-PNS
  final guru2Count = Sqflite.firstIntValue(
    await dbHelper.database.query('users', where: 'username = ?', whereArgs: ['guru2'])
  );
  if (guru2Count == null || guru2Count == 0) {
    await dbHelper.insertUser({
      'username': 'guru2',
      'password': 'guru123',
      'name': 'Guru Dua',
      'role': 'guru',
      'type': 'non_pns',
      'nip': null,
      'npwp': null,
      'created_at': DateTime.now().toIso8601String(),
      'updated_at': DateTime.now().toIso8601String(),
    });
  }

  // Initial settings
  await dbHelper.insertOrUpdateSetting('center_lat', '-7.797068');
  await dbHelper.insertOrUpdateSetting('center_lng', '110.370529');
  await dbHelper.insertOrUpdateSetting('max_distance_m', '1000');
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Absensi Guru',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const LoginPage(),
    );
  }
}
```

```dart
// lib/models/user.dart
class User {
  final int? id;
  final String username;
  final String password; // Note: Plaintext for POC; hash in production
  final String name;
  final String role; // super_admin, admin, guru
  final String type; // pns, non_pns
  final String? nip;
  final String? npwp;
  final DateTime createdAt;
  final DateTime updatedAt;

  User({
    this.id,
    required this.username,
    required this.password,
    required this.name,
    required this.role,
    required this.type,
    this.nip,
    this.npwp,
    required this.createdAt,
    required this.updatedAt,
  });

  factory User.fromMap(Map<String, dynamic> map) {
    return User(
      id: map['id'],
      username: map['username'],
      password: map['password'],
      name: map['name'],
      role: map['role'],
      type: map['type'],
      nip: map['nip'],
      npwp: map['npwp'],
      createdAt: DateTime.parse(map['created_at']),
      updatedAt: DateTime.parse(map['updated_at']),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'username': username,
      'password': password,
      'name': name,
      'role': role,
      'type': type,
      'nip': nip,
      'npwp': npwp,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }
}
```

```dart
// lib/models/attendance.dart
class Attendance {
  final int? id;
  final int userId;
  final String date; // yyyy-MM-dd
  final String type; // check_in, check_out
  final String time; // HH:mm:ss
  final String photoPath;
  final double latitude;
  final double longitude;
  final double distanceM;
  final String status; // pending, validated, rejected
  final String? adminComment;
  final int? validatedBy;
  final DateTime createdAt;
  final DateTime updatedAt;

  Attendance({
    this.id,
    required this.userId,
    required this.date,
    required this.type,
    required this.time,
    required this.photoPath,
    required this.latitude,
    required this.longitude,
    required this.distanceM,
    required this.status,
    this.adminComment,
    this.validatedBy,
    required this.createdAt,
    required this.updatedAt,
  });

  factory Attendance.fromMap(Map<String, dynamic> map) {
    return Attendance(
      id: map['id'],
      userId: map['user_id'],
      date: map['date'],
      type: map['type'],
      time: map['time'],
      photoPath: map['photo_path'],
      latitude: map['latitude'],
      longitude: map['longitude'],
      distanceM: map['distance_m'],
      status: map['status'],
      adminComment: map['admin_comment'],
      validatedBy: map['validated_by'],
      createdAt: DateTime.parse(map['created_at']),
      updatedAt: DateTime.parse(map['updated_at']),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'user_id': userId,
      'date': date,
      'type': type,
      'time': time,
      'photo_path': photoPath,
      'latitude': latitude,
      'longitude': longitude,
      'distance_m': distanceM,
      'status': status,
      'admin_comment': adminComment,
      'validated_by': validatedBy,
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt.toIso8601String(),
    };
  }
}
```

```dart
// lib/services/db_helper.dart
import 'dart:io';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:path_provider/path_provider.dart';
import '../models/user.dart';
import '../models/attendance.dart';

class DBHelper {
  static Database? _database;
  static final DBHelper instance = DBHelper._init();
  DBHelper._init();

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB('absensi_guru.db');
    return _database!;
  }

  static Future<Database> _initDB(String filePath) async {
    // Initialize FFI for desktop
    if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) {
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }

    String path;
    if (Platform.isAndroid) {
      path = '/databases/$filePath';
    } else {
      Directory documentsDirectory = await getApplicationDocumentsDirectory();
      path = join(documentsDirectory.path, filePath);
    }

    return await openDatabase(path, version: 1, onCreate: _createDB);
  }

  static Future _createDB(Database db, int version) async {
    // Users table
    await db.execute('''
    CREATE TABLE users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      name TEXT NOT NULL,
      role TEXT NOT NULL CHECK(role IN ('super_admin','admin','guru')),
      type TEXT CHECK(type IN ('pns','non_pns')) DEFAULT 'non_pns',
      nip TEXT,
      npwp TEXT,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    )
    ''');

    // Attendance table
    await db.execute('''
    CREATE TABLE attendance (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      user_id INTEGER NOT NULL REFERENCES users(id),
      date TEXT NOT NULL,
      type TEXT NOT NULL CHECK(type IN ('check_in','check_out')),
      time TEXT NOT NULL,
      photo_path TEXT NOT NULL,
      latitude REAL NOT NULL,
      longitude REAL NOT NULL,
      distance_m REAL NOT NULL,
      status TEXT NOT NULL CHECK(status IN ('pending','validated','rejected')) DEFAULT 'pending',
      admin_comment TEXT,
      validated_by INTEGER,
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    )
    ''');

    // Settings table
    await db.execute('''
    CREATE TABLE settings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      key TEXT UNIQUE NOT NULL,
      value TEXT NOT NULL
    )
    ''');
  }

  static Future<void> initDB() async {
    await instance.database;
  }

  Future<int> insertUser(Map<String, dynamic> userMap) async {
    final db = await database;
    return await db.insert('users', userMap);
  }

  Future<User?> getUserByUsername(String username) async {
    final db = await database;
    final maps = await db.query(
      'users',
      where: 'username = ?',
      whereArgs: [username],
    );
    if (maps.isNotEmpty) {
      return User.fromMap(maps.first);
    }
    return null;
  }

  Future<List<User>> getAllUsers() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query('users');
    return List.generate(maps.length, (i) => User.fromMap(maps[i]));
  }

  Future<int> updateUser(User user) async {
    final db = await database;
    return await db.update(
      'users',
      user.toMap(),
      where: 'id = ?',
      whereArgs: [user.id],
    );
  }

  Future<int> deleteUser(int id) async {
    final db = await database;
    return await db.delete(
      'users',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  // Attendance CRUD
  Future<int> insertAttendance(Map<String, dynamic> attMap) async {
    final db = await database;
    return await db.insert('attendance', attMap);
  }

  Future<List<Attendance>> getPendingAttendances() async {
    final db = await database;
    final List<Map<String, dynamic>> maps = await db.query(
      'attendance',
      where: 'status = ?',
      whereArgs: ['pending'],
      orderBy: 'date DESC, time ASC',
    );
    return List.generate(maps.length, (i) => Attendance.fromMap(maps[i]));
  }

  Future<Attendance?> getAttendance(int id) async {
    final db = await database;
    final maps = await db.query(
      'attendance',
      where: 'id = ?',
      whereArgs: [id],
    );
    if (maps.isNotEmpty) {
      return Attendance.fromMap(maps.first);
    }
    return null;
  }

  Future<List<Attendance>> getUserAttendances(int userId, {String? date}) async {
    final db = await database;
    List<String> whereArgs = [userId.toString()];
    String whereClause = 'user_id = ?';
    if (date != null) {
      whereClause += ' AND date = ?';
      whereArgs.add(date);
    }
    final List<Map<String, dynamic>> maps = await db.query(
      'attendance',
      where: whereClause,
      whereArgs: whereArgs,
      orderBy: 'date DESC, time ASC',
    );
    return List.generate(maps.length, (i) => Attendance.fromMap(maps[i]));
  }

  Future<int> updateAttendance(Attendance attendance) async {
    final db = await database;
    return await db.update(
      'attendance',
      attendance.toMap(),
      where: 'id = ?',
      whereArgs: [attendance.id],
    );
  }

  // Settings
  Future<void> insertOrUpdateSetting(String key, String value) async {
    final db = await database;
    await db.insert('settings', {'key': key, 'value': value},
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  Future<String?> getSetting(String key) async {
    final db = await database;
    final maps = await db.query('settings', where: 'key = ?', whereArgs: [key]);
    if (maps.isNotEmpty) {
      return maps.first['value'];
    }
    return null;
  }
}
```

```dart
// lib/services/auth_service.dart
import '../models/user.dart';
import 'db_helper.dart';

class AuthService {
  static User? _currentUser;

  static Future<bool> login(String username, String password) async {
    final dbHelper = DBHelper();
    final user = await dbHelper.getUserByUsername(username);
    if (user != null && user.password == password) { // Plaintext for POC
      _currentUser = user;
      return true;
    }
    return false;
  }

  static User? get currentUser => _currentUser;

  static void logout() {
    _currentUser = null;
  }

  static bool isSuperAdmin() => _currentUser?.role == 'super_admin';
  static bool isAdmin() => _currentUser?.role == 'admin';
  static bool isGuru() => _currentUser?.role == 'guru';
}
```

```dart
// lib/services/location_service.dart
import 'dart:math';
import 'package:geolocator/geolocator.dart';
import 'package:permission_handler/permission_handler.dart';
import 'db_helper.dart';

class LocationService {
  // Haversine formula to calculate distance
  static double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
    const double earthRadius = 6371000; // meters
    double dLat = (lat2 - lat1) * pi / 180;
    double dLon = (lon2 - lon1) * pi / 180;
    double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(lat1 * pi / 180) * cos(lat2 * pi / 180) * sin(dLon / 2) * sin(dLon / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    return earthRadius * c;
  }

  static Future<bool> requestPermissions() async {
    final cameraStatus = await Permission.camera.request();
    final locationStatus = await Permission.location.request();
    return cameraStatus.isGranted && locationStatus.isGranted;
  }

  static Future<Position?> getCurrentPosition() async {
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return null;
    }

    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      return null;
    }

    return await Geolocator.getCurrentPosition(desiredAccuracy: LocationAccuracy.high);
  }

  static Future<bool> isWithinRadius(double lat, double lng) async {
    final dbHelper = DBHelper();
    final centerLatStr = await dbHelper.getSetting('center_lat');
    final centerLngStr = await dbHelper.getSetting('center_lng');
    final maxDistStr = await dbHelper.getSetting('max_distance_m');

    if (centerLatStr == null || centerLngStr == null || maxDistStr == null) {
      return false;
    }

    final centerLat = double.parse(centerLatStr);
    final centerLng = double.parse(centerLngStr);
    final maxDist = double.parse(maxDistStr);

    final distance = calculateDistance(centerLat, centerLng, lat, lng);
    return distance <= maxDist;
  }
}
```

```dart
// lib/services/attendance_service.dart
import 'dart:io';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:image_picker/image_picker.dart';
import '../models/attendance.dart';
import 'db_helper.dart';
import 'location_service.dart';

class AttendanceService {
  static Future<String?> takeSelfie() async {
    final picker = ImagePicker();
    final XFile? image = await picker.pickImage(source: ImageSource.camera);
    if (image == null) return null;

    final directory = await getApplicationDocumentsDirectory();
    final fileName = 'selfie_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final savedImage = await File(image.path).copy('${directory.path}/$fileName');
    return savedImage.path;
  }

  static Future<Attendance?> createAttendance(int userId, String type) async {
    // Check if already attended today for this type
    final dbHelper = DBHelper();
    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final existing = await dbHelper.getUserAttendances(userId, date: today);
    final alreadyDone = existing.any((att) => att.type == type && att.status == 'validated');
    if (alreadyDone) {
      throw Exception('Already attended $type today');
    }

    // Take selfie
    final photoPath = await takeSelfie();
    if (photoPath == null) {
      throw Exception('Failed to take selfie');
    }

    // Get location
    final position = await LocationService.getCurrentPosition();
    if (position == null) {
      throw Exception('Failed to get location');
    }

    final isWithin = await LocationService.isWithinRadius(position.latitude, position.longitude);
    if (!isWithin) {
      throw Exception('Outside allowed radius');
    }

    final distance = await _getDistanceToCenter(position.latitude, position.longitude);

    final now = DateTime.now();
    final attendance = Attendance(
      userId: userId,
      date: DateFormat('yyyy-MM-dd').format(now),
      type: type,
      time: DateFormat('HH:mm:ss').format(now),
      photoPath: photoPath,
      latitude: position.latitude,
      longitude: position.longitude,
      distanceM: distance,
      status: 'pending',
      createdAt: now,
      updatedAt: now,
    );

    final id = await dbHelper.insertAttendance(attendance.toMap());
    attendance.id = id;
    return attendance;
  }

  static Future<double> _getDistanceToCenter(double lat, double lng) async {
    final dbHelper = DBHelper();
    final centerLatStr = await dbHelper.getSetting('center_lat');
    final centerLngStr = await dbHelper.getSetting('center_lng');
    if (centerLatStr == null || centerLngStr == null) return 0.0;
    final centerLat = double.parse(centerLatStr);
    final centerLng = double.parse(centerLngStr);
    return LocationService.calculateDistance(centerLat, centerLng, lat, lng);
  }

  static Future<void> validateAttendance(int attendanceId, String status, String? comment, int adminId) async {
    if (status != 'validated' && status != 'rejected') {
      throw Exception('Invalid status');
    }
    final dbHelper = DBHelper();
    final attendance = await dbHelper.getAttendance(attendanceId);
    if (attendance == null) throw Exception('Attendance not found');

    attendance.status = status;
    attendance.adminComment = comment;
    attendance.validatedBy = adminId;
    attendance.updatedAt = DateTime.now();

    await dbHelper.updateAttendance(attendance);
  }
}
```

```dart
// lib/services/export_service.dart
import 'dart:io';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:csv/csv.dart';
import '../models/user.dart';
import 'db_helper.dart';

class ExportService {
  static Future<String> exportAttendanceToCsv({DateTime? startDate, DateTime? endDate}) async {
    final dbHelper = DBHelper();
    final now = DateTime.now();
    startDate ??= now.subtract(const Duration(days: 30));
    endDate ??= now;

    final startStr = DateFormat('yyyy-MM-dd').format(startDate);
    final endStr = DateFormat('yyyy-MM-dd').format(endDate);

    final attendances = await dbHelper.database.query(
      'attendance',
      where: 'date BETWEEN ? AND ?',
      whereArgs: [startStr, endStr],
      orderBy: 'date ASC, time ASC',
    );

    final users = await dbHelper.getAllUsers();
    final userMap = {for (var u in users) u.id: u};

    List<List<dynamic>> csvData = [
      ['Tanggal', 'Nama', 'NIP', 'Type', 'Waktu', 'Status', 'Jarak (m)', 'Photo Path']
    ];

    for (var attMap in attendances) {
      final att = Attendance.fromMap(attMap);
      final user = userMap[att.userId];
      if (user == null) continue;

      csvData.add([
        att.date,
        user.name,
        user.nip ?? '',
        att.type,
        att.time,
        att.status,
        att.distanceM.toStringAsFixed(2),
        att.photoPath,
      ]);
    }

    String csv = const ListToCsvConverter().convert(csvData);

    final directory = await getExternalStorageDirectory();
    final path = '${directory?.path}/absensi_rekap_${DateFormat('yyyyMMdd').format(now)}.csv';
    final file = File(path ?? '${(await getApplicationDocumentsDirectory()).path}/absensi_rekap_${DateFormat('yyyyMMdd').format(now)}.csv');
    await file.writeAsString(csv);

    // Simple stats (you can expand)
    final validatedCount = attendances.where((a) => a['status'] == 'validated').length;
    print('Exported ${attendances.length} records, $validatedCount validated.'); // For now, print; can add to CSV

    return file.path;
  }
}
```

```dart
// lib/screens/login_page.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/auth_service.dart';
import 'dashboard.dart';

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;

  Future<void> _login() async {
    setState(() => _isLoading = true);
    final success = await AuthService.login(_usernameController.text, _passwordController.text);
    if (success) {
      if (mounted) {
        Navigator.pushReplacement(
          context,
          MaterialPageRoute(builder: (context) => const Dashboard()),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Login failed')));
    }
    setState(() => _isLoading = false);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            TextField(
              controller: _usernameController,
              decoration: const InputDecoration(labelText: 'Username'),
            ),
            TextField(
              controller: _passwordController,
              decoration: const InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: _isLoading ? null : _login,
              child: _isLoading ? const CircularProgressIndicator() : const Text('Login'),
            ),
          ],
        ),
      ),
    );
  }
}
```

```dart
// lib/screens/dashboard.dart
import 'package:flutter/material.dart';
import '../services/auth_service.dart';
import 'admin/pending_list.dart';
import 'guru/attendance_form.dart';
import 'super_admin/settings_page.dart';
import 'super_admin/manage_users.dart';

class Dashboard extends StatelessWidget {
  const Dashboard({super.key});

  @override
  Widget build(BuildContext context) {
    final userRole = AuthService.currentUser?.role;

    Widget body;
    switch (userRole) {
      case 'super_admin':
        body = const SuperAdminDashboard();
        break;
      case 'admin':
        body = const PendingListPage();
        break;
      case 'guru':
        body = const AttendanceForm();
        break;
      default:
        body = const Center(child: Text('Unknown role'));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Dashboard'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () {
              AuthService.logout();
              Navigator.pushReplacementNamed(context, '/login');
            },
          ),
        ],
      ),
      body: body,
    );
  }
}

class SuperAdminDashboard extends StatelessWidget {
  const SuperAdminDashboard({super.key});

  @override
  Widget build(BuildContext context) {
    return ListView(
      children: [
        ListTile(
          title: const Text('Manage Users'),
          leading: const Icon(Icons.people),
          onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const ManageUsersPage())),
        ),
        ListTile(
          title: const Text('Settings'),
          leading: const Icon(Icons.settings),
          onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const SettingsPage())),
        ),
        ListTile(
          title: const Text('Pending Attendances'),
          leading: const Icon(Icons.list),
          onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const PendingListPage())),
        ),
      ],
    );
  }
}
```

```dart
// lib/screens/guru/attendance_form.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../../services/auth_service.dart';
import '../../services/attendance_service.dart';
import '../../services/location_service.dart';
import '../history_page.dart';

class AttendanceForm extends StatefulWidget {
  const AttendanceForm({super.key});

  @override
  State<AttendanceForm> createState() => _AttendanceFormState();
}

class _AttendanceFormState extends State<AttendanceForm> {
  bool _isLoading = false;
  String? _error;
  bool _canCheckIn = true;
  bool _canCheckOut = true;

  @override
  void initState() {
    super.initState();
    _checkTodayAttendance();
    _requestPermissions();
  }

  Future<void> _requestPermissions() async {
    final granted = await LocationService.requestPermissions();
    if (!granted && mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Permissions required for camera and location')));
    }
  }

  Future<void> _checkTodayAttendance() async {
    final userId = AuthService.currentUser!.id!;
    final dbHelper = DBHelper(); // Assuming import
    final today = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final attendances = await dbHelper.getUserAttendances(userId, date: today);
    final validatedIn = attendances.any((a) => a.type == 'check_in' && a.status == 'validated');
    final validatedOut = attendances.any((a) => a.type == 'check_out' && a.status == 'validated');
    if (mounted) {
      setState(() {
        _canCheckIn = !validatedIn;
        _canCheckOut = !validatedOut;
      });
    }
  }

  Future<void> _performAttendance(String type) async {
    setState(() => _isLoading = true);
    try {
      await AttendanceService.createAttendance(AuthService.currentUser!.id!, type);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Attendance $type submitted (pending validation)')));
        _checkTodayAttendance();
      }
    } catch (e) {
      if (mounted) {
        setState(() => _error = e.toString());
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Guru Dashboard')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            ElevatedButton(
              onPressed: _isLoading || !_canCheckIn ? null : () => _performAttendance('check_in'),
              child: const Text('Absen Masuk'),
            ),
            ElevatedButton(
              onPressed: _isLoading || !_canCheckOut ? null : () => _performAttendance('check_out'),
              child: const Text('Absen Pulang'),
            ),
            if (_error != null) Text('Error: $_error', style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const HistoryPage())),
              child: const Text('Riwayat Absen'),
            ),
          ],
        ),
      ),
    );
  }
}
```

```dart
// lib/screens/history_page.dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../services/auth_service.dart';
import '../services/db_helper.dart';

class HistoryPage extends StatefulWidget {
  const HistoryPage({super.key});

  @override
  State<HistoryPage> createState() => _HistoryPageState();
}

class _HistoryPageState extends State<HistoryPage> {
  List<Map<String, dynamic>> _attendances = [];

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    final userId = AuthService.currentUser!.id!;
    final dbHelper = DBHelper();
    final attendances = await dbHelper.getUserAttendances(userId);
    if (mounted) {
      setState(() => _attendances = attendances.map((a) => a.toMap()).toList());
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Riwayat Absen')),
      body: ListView.builder(
        itemCount: _attendances.length,
        itemBuilder: (context, index) {
          final att = _attendances[index];
          return ListTile(
            title: Text('${att['date']} - ${att['type']}'),
            subtitle: Text('${att['time']} - Status: ${att['status']}'),
          );
        },
      ),
    );
  }
}
```

```dart
// lib/screens/admin/pending_list.dart
import 'package:flutter/material.dart';
import '../../services/db_helper.dart';
import '../../models/attendance.dart';
import 'validate_screen.dart';

class PendingListPage extends StatefulWidget {
  const PendingListPage({super.key});

  @override
  State<PendingListPage> createState() => _PendingListPageState();
}

class _PendingListPageState extends State<PendingListPage> {
  List<Attendance> _pendings = [];

  @override
  void initState() {
    super.initState();
    _loadPendings();
  }

  Future<void> _loadPendings() async {
    final dbHelper = DBHelper();
    final pendings = await dbHelper.getPendingAttendances();
    if (mounted) {
      setState(() => _pendings = pendings);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Pending Attendances')),
      body: ListView.builder(
        itemCount: _pendings.length,
        itemBuilder: (context, index) {
          final att = _pendings[index];
          return ListTile(
            title: Text('${att.date} - ${att.type}'),
            subtitle: Text('Distance: ${att.distanceM.toStringAsFixed(0)}m'),
            onTap: () => Navigator.push(
              context,
              MaterialPageRoute(
                builder: (_) => ValidateScreen(attendance: att),
              ),
            ).then((_) => _loadPendings()),
          );
        },
      ),
    );
  }
}
```

```dart
// lib/screens/admin/validate_screen.dart
import 'package:flutter/material.dart';
import '../../services/auth_service.dart';
import '../../services/attendance_service.dart';
import '../../models/attendance.dart';

class ValidateScreen extends StatefulWidget {
  final Attendance attendance;
  const ValidateScreen({super.key, required this.attendance});

  @override
  State<ValidateScreen> createState() => _ValidateScreenState();
}

class _ValidateScreenState extends State<ValidateScreen> {
  final _commentController = TextEditingController();
  bool _isLoading = false;

  Future<void> _validate(String status) async {
    setState(() => _isLoading = true);
    try {
      final adminId = AuthService.currentUser!.id!;
      await AttendanceService.validateAttendance(
        widget.attendance.id!,
        status,
        _commentController.text.isEmpty ? null : _commentController.text,
        adminId,
      );
      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Updated to $status')));
      }
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('${widget.attendance.type} Validation')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Date: ${widget.attendance.date}'),
            Text('Time: ${widget.attendance.time}'),
            Text('Lat: ${widget.attendance.latitude}, Lng: ${widget.attendance.longitude}'),
            Text('Distance: ${widget.attendance.distanceM.toStringAsFixed(0)}m'),
            Text('Photo: ${widget.attendance.photoPath}'), // Preview widget can be added
            TextField(
              controller: _commentController,
              decoration: const InputDecoration(labelText: 'Comment'),
              maxLines: 3,
            ),
            const SizedBox(height: 20),
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : () => _validate('validated'),
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.green),
                    child: const Text('Approve'),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _isLoading ? null : () => _validate('rejected'),
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                    child: const Text('Reject'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

```dart
// lib/screens/super_admin/manage_users.dart
import 'package:flutter/material.dart';
import '../../models/user.dart';
import '../../services/db_helper.dart';
import '../../services/auth_service.dart';

class ManageUsersPage extends StatefulWidget {
  const ManageUsersPage({super.key});

  @override
  State<ManageUsersPage> createState() => _ManageUsersPageState();
}

class _ManageUsersPageState extends State<ManageUsersPage> {
  List<User> _users = [];

  @override
  void initState() {
    super.initState();
    _loadUsers();
  }

  Future<void> _loadUsers() async {
    final dbHelper = DBHelper();
    final users = await dbHelper.getAllUsers();
    if (mounted) setState(() => _users = users);
  }

  Future<void> _deleteUser(int id) async {
    final dbHelper = DBHelper();
    await dbHelper.deleteUser(id);
    _loadUsers();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Manage Users')),
      body: ListView.builder(
        itemCount: _users.length,
        itemBuilder: (context, index) {
          final user = _users[index];
          if (user.id == AuthService.currentUser?.id) return const SizedBox(); // Skip self
          return ListTile(
            title: Text(user.name),
            subtitle: Text('${user.username} - ${user.role}'),
            trailing: IconButton(
              icon: const Icon(Icons.delete),
              onPressed: () => _deleteUser(user.id!),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Add user dialog/form here (minimal, skipped for brevity)
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}
```

```dart
// lib/screens/super_admin/settings_page.dart
import 'package:flutter/material.dart';
import '../../services/db_helper.dart';

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});

  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  final _latController = TextEditingController();
  final _lngController = TextEditingController();
  final _distController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final dbHelper = DBHelper();
    _latController.text = (await dbHelper.getSetting('center_lat')) ?? '';
    _lngController.text = (await dbHelper.getSetting('center_lng')) ?? '';
    _distController.text = (await dbHelper.getSetting('max_distance_m')) ?? '';
  }

  Future<void> _saveSettings() async {
    final dbHelper = DBHelper();
    await dbHelper.insertOrUpdateSetting('center_lat', _latController.text);
    await dbHelper.insertOrUpdateSetting('center_lng', _lngController.text);
    await dbHelper.insertOrUpdateSetting('max_distance_m', _distController.text);
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Settings saved')));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            TextField(
              controller: _latController,
              decoration: const InputDecoration(labelText: 'Center Latitude'),
            ),
            TextField(
              controller: _lngController,
              decoration: const InputDecoration(labelText: 'Center Longitude'),
            ),
            TextField(
              controller: _distController,
              decoration: const InputDecoration(labelText: 'Max Distance (m)'),
              keyboardType: TextInputType.number,
            ),
            ElevatedButton(onPressed: _saveSettings, child: const Text('Save')),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          // Export
          final path = await ExportService.exportAttendanceToCsv();
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Exported to $path')));
          }
        },
        child: const Icon(Icons.download),
      ),
    );
  }
}
```

# README.md

## Absensi Guru - Flutter App

Aplikasi absensi guru menggunakan Flutter dengan selfie dan GPS, database SQLite.

### Dependencies
Pastikan pubspec.yaml sesuai. Jalankan `flutter pub get`.

### Cara Run di Android
1. `flutter run` di emulator/device Android.
2. Permissions akan diminta saat pertama kali.

### Cara Run di Windows
1. Enable Flutter desktop: `flutter config --enable-windows-desktop`.
2. `flutter run -d windows`.
3. sqflite_common_ffi handles SQLite on Windows.

### Login Credentials (Seed Data)
- Super Admin: username `super`, password `admin123`
- Admin: `admin` / `admin123`
- Guru 1 (PNS): `guru1` / `guru123`
- Guru 2 (non-PNS): `guru2` / `guru123`

### Notes
- Password plaintext untuk POC; implement bcrypt untuk production.
- Foto disimpan di app documents directory.
- Export CSV ke external storage atau app dir.
- Map preview skipped; tambahkan google_maps_flutter jika diperlukan.
- CRUD users minimal; extend manage_users untuk create/edit/reset password.

### Dokumentasi Singkat
- **DBHelper**: Handles SQLite init, CRUD for users, attendance, settings.
- **AuthService**: Simple login/logout.
- **LocationService**: GPS, distance calc (Haversine).
- **AttendanceService**: Create attendance with validation.
- **ExportService**: CSV export 30 days with basic stats.